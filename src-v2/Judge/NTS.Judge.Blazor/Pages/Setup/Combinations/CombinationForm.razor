@using NTS.Domain.Core.Configuration
@using NTS.Domain.Setup.Entities;
@using NTS.Judge.Blazor.Pages.Setup.RfidTags
@using Not.Blazor.TM;
@using Not.Blazor.TM.Models;
@using Not.Blazor.TM.Forms;
@using Not.Blazor.TM.Forms.Components;

@inherits FormTM<CombinationFormModel>

<EditForm Model="Model">
    <MudNumericField @ref="_numberField" @bind-Value="Model.Number" T="int" Min="0" Label="@Localizer.Get("Combination Number")" />

    <NotAutocomplete @ref="_athleteField" @bind-Value="Model.Athlete" Label="Athlete" Search="SearchAthletes" />

    <NotAutocomplete @ref="_horseField" @bind-Value="Model.Horse" Label="Horse" Search="SearchHorses"/>

    @if (StaticOptions.IsRfidDetectionEnabled())
    {
        <RfidTagWriter CombinationNumber="Model.Number" @bind-Value="Model.Tag" />
    }
</EditForm>

@code {
    MudNumericField<int> _numberField = default!;
    NotAutocomplete<Athlete?> _athleteField = default!;
    NotAutocomplete<Horse?> _horseField = default!;
    List<NotListModel<Athlete>> _athletes = [];
    List<NotListModel<Horse>> _horses = [];

    [Inject]
    IListBehind<Athlete> _athletesBehind { get; set; } = default!;
    [Inject]
    IListBehind<Horse> _horsesBehind { get; set; } = default!;

    protected async override Task OnInitializedAsync()
    {
        await Observe(_athletesBehind);
        await Observe(_horsesBehind);
        _athletes = NotListModel.FromEntity<Athlete>(_athletesBehind.Items).ToList();
        _horses = NotListModel.FromEntity<Horse>(_horsesBehind.Items).ToList();
    }

    public override void RegisterValidationInjectors()
    {
        RegisterInjector(nameof(Combination.Number), () => _numberField);
        RegisterInjector(nameof(Combination.Athlete), () => _athleteField);
        RegisterInjector(nameof(Combination.Horse), () => _horseField);
    }

    Task<IEnumerable<Athlete>> SearchAthletes(string term)
    {
        var result = Search(_athletesBehind.Items, term);
        return Task.FromResult(result);
    }

    Task<IEnumerable<Horse>> SearchHorses(string term)
    {
        var result = Search(_horsesBehind.Items, term);
        return Task.FromResult(result);
    }

    // TODO: extract search functionality somehow, because ToString() should be identical (maybe ToString should be configurable)
    IEnumerable<T> Search<T>(IEnumerable<T> values, string term)
    {
        if (string.IsNullOrWhiteSpace(term))
        {
            return values;
        }
        return values.Where(x => x != null && x.ToString()!.Contains(term, StringComparison.InvariantCultureIgnoreCase));
    }
}